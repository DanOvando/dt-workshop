---
title: "Eco-data-science data.table workshop"
output: html_notebook

---

### shortcuts

Run Chunk : *Cmd+Shift+Enter*

Insert Chunk : *Cmd+Option+I*

Preview HTML : *Cmd+Shift+K*

# Introduction

## About the data

The datasets we will be using in this interactive session are taken from the Environmental Protection Agency's (EPA) Air Markets Program Data (AMPD) program. The first dataset (the ``epa_ampd_hourly_2019_selected.csv`` file) is a dataset of hourly emissions, electriticity generation, and fuel consumption for coal and natural gas across the country. Because the full dataset downloaded from the AMPD site is extremely large, we have filtered out the dataset to only have generators in the states of X, Y, and Z. 

The second dataset (the ``facility_01-27-2021_224024745.csv`` file) is a list of generators and various attributes, such as their fuel type, generator type, and location.

(explain the different columns)

# Packages

## Install packages

Along with the ``data.table`` package, we will also be using the ``here`` package for this notebook. The ``here`` package basically helps us [write something here]. 
We also briefly use the ``janitor`` package to clean up column names.
```{r}
# install.packages("data.table")
# install.packages("here")
# install.packages("janitor")
```

## Load packages

Load the ``data.table`` and ``janitor`` packages. We don't need to load the ``here`` package because we can explicitly call on the package when using the here function (``here::here()``).
```{r}
library(data.table)
library(janitor)
```

# Read in data

## File names
Here, we are just explicitly setting objects/variables for the data files, so we can easily use them later.
```{r}
hourly_data     = 'epa_ampd_hourly_2019_selected.csv'
facility_data   = 'facility_01-27-2021_224024745.csv'
```

## Read in CSV files

Use the ``fread`` function to read in the hourly data. 
```{r}
dt = fread(here::here("data", hourly_data))
```

View first few rows of the hourly data:
```{r}
head(dt)
```
We can see that the column names are not ideal (spaces and parantheses are not easy to work with). Thus, let's use the ``janitor`` package to clean up the column names:
```{r}
dt = clean_names(dt)
head(dt)
```
Nice! Now the column names are all lower case, the spaces have been replaced with underscores, and the parantheses and slashes are gone. There are some problematic column names (for example, mmBtu has been changed to mm_btu, but we will fix those columns later).

# Basics

## Setting keys

Setting keys for the datatable can help speed up processes later, particularly for columns/keys that you frequently use (e.g., if you keep summarizing across the same groups). So, let's set the keys of ``dt`` as the orispl_code, unitid, op_date, and op_hour columns:

```{r}
setkey(dt, orispl_code, unitid, op_date, op_hour)
```

## Filter rows

In this section, we will go over how to filter the datatable's rows in a multitude of ways.

### Filter for rows for generators in California (CA)
```{r}
dt[state=="CA"]
```
### Filter for rows that occurred after july 1, 2019
```{r}
dt[op_date > "07-01-2019"]
```
### Filter for rows for facilities with the word "Energy" in its name
```{r}
dt[facility_name %like% "Energy"]
```
### Filter for rows that are within California and New Jersey
```{r}
dt[state %chin% c("CA", "NJ")]
```
All of the filters thus far only print the resulting rows but do not actually save to a data.table. Let's filter out our existing ``dt`` object to only have rows where neither the ``gload_mw`` or the ``heat_input_mm_btu`` columns are NA.
```{r}
dt = dt[!is.na(gload_mw) & !is.na(heat_input_mm_btu)]
head(dt)
```

## Select columns

### Select columns by name
```{r}
dt[, .(orispl_code, unitid, op_date, op_hour, op_time, gload_mw)]
```
### Select columns by column number/index
```{r}
dt[, c(3:8)]
```

Let's only keep the following columns:
* state
* orispl_code
* unitid
* op_date
* op_hour
* gload_mw
* so2_mass_lbs
* nox_mass_lbs
* co2_mass_tons
* heat_input_mm_btu
```{r}
dt = dt[, .(state, orispl_code, unitid, op_date, op_hour, gload_mw, so2_mass_lbs, nox_mass_lbs, co2_mass_tons, heat_input_mm_btu)]
head(dt)
```

# Modifying the datatable

## Rename columns

### Renaming single columns
```{r}
setnames(dt, "heat_input_mm_btu", "heat_input_mmbtu")
head(dt)
```

## Reorder rows

### Temporarily sorting
```{r}
dt[order(-gload_mw)]
```
### Actually sorting the data table

Order ``dt`` by the orispl_code column:
```{r}
setorder(dt, orispl_code, na.last = TRUE)
head(dt)
```
We can also order the datable by multiple columns. For example, let's say we want ``dt`` to be ordered by the following columns (in this order): state, orispl_code, unitid, op_date, and op_hour. 
```{r}
setorder(dt, state, orispl_code, unitid, op_date, op_hour)
head(dt)
```

## Summarize/aggregate

### Summarize by group(s)

Let's find the total amount of CO2 emitted by state and by date:
```{r}
dt[, .(total_co2_tons = sum(co2_mass_tons, na.rm = T)), by = .(op_date)]
```

### summarize several columns

``.SD`` can be used to summarize multiple columns
```{r}
dt[, lapply(.SD, sum, na.rm = T), .SDcols = c("co2_mass_tons", "so2_mass_lbs", "nox_mass_lbs")]
```

### summarize several columns by group(s)

We can also use ``.SD`` by group:
```{r}
dt[, lapply(.SD, sum, na.rm = T), .SDcols = c("co2_mass_tons", "so2_mass_lbs", "nox_mass_lbs"), by = .(state)]
```

### summarize multiple functions on several columns by group(s)

The ``.N`` special character can be used to count the number of observations. Not to be confused with the ``uniqueN`` function, which counts the number of *unique* observations. Let's find the number of observations, the number of power plants, and the total generation by state:
```{r}
dt[, .(number_of_observations = .N,
       number_of_plants = uniqueN(orispl_code),
       total_generation = sum(gload_mw, na.rm = T)), by = .(state)]
```

## add columns

Let's extract the month as the column ``op_month``:
```{r}
dt[, op_month := substr(op_date, 1, 2)]
head(dt)
```
You can remove a column by setting it to NULL (``dt[, column_name := NULL]``).

To change an existing column, you can just use the same method without changing the column name. For example, we can see that currently, the ``gload_mw`` is of the integer type.
```{r}
str(dt)
```

When really it should be a numeric value. So let's change the column to a numeric type:
```{r}
dt[, gload_mw := as.numeric(gload_mw)]
str(dt)
```

## Replace values

Creating a new column does not mean that all new rows of the column have to be populated. Similarly, not all rows of an existing column need to be replaced. You can filter rows when creating a new column or modifying an existing one. 

## Add columns by groups

Let's say we want to add a column that's the max generation for each generator:
```{r}
dt[, max_gen := max(gload_mw, na.rm = T), by = .(orispl_code, unitid)]
head(dt)
```

### Add multiple columns

One way to add multiple columns is to use the LHS := RHS method
```{r}
dt[, c("heat_rate_mmbtu_mwh", "efficiency") := .(gload_mw/heat_input_mmbtu, (heat_input_mmbtu/gload_mw)*3.412)]
head(dt)
```
Another way to add multiple columns is to use the functional form.
```{r}
dt[, ':=' (co2_rate_tons_mwh = co2_mass_tons/gload_mw, nox_rate_lbs_mwh = nox_mass_lbs/gload_mw, so2_rate_lbs_mwh = so2_mass_lbs/gload_mw)]
head(dt)
```
## Reshape between long and wide forms

### Melt (wide to long)

```{r}
dt_long = melt(dt, 
               id.vars = c("orispl_code", "unitid", "op_date", "op_hour"), 
               measure.vars = c("co2_mass_tons", "so2_mass_lbs", "nox_mass_lbs"))
head(dt_long)
```

### dcast (long to wide)

```{r}
dt_wide = dcast(dt_long, orispl_code + unitid + op_date + op_hour ~ variable)
head(dt_wide)
```

# Joining data

### Read in facility data
```{r}
fac_dt = fread(here::here('data', facility_data))
head(fac_dt)
```
Fix column names with the ``janitor`` package:
```{r}
fac_dt = clean_names(fac_dt)
head(fac_dt)
```

## Merge

Merge (version 1):
```{r}
combined_dt = merge(dt, fac_dt, 
      by.x = c("state", "orispl_code", "unitid"),
      by.y = c("state", "facility_id_orispl", "unit_id"))
head(combined_dt)
```
Merge (version 2):
```{r}
combined_v2 = dt[fac_dt, on = .(state = state, orispl_code = facility_id_orispl, unitid = unit_id), nomatch = 0]
head(combined_v2)
```

## Bind

# Beyond...

How much electricity generation, NOx emissions, SO2 emissions, etc are coming from coal vs natural gas plants?